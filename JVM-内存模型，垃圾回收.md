# JVM-内存模型，垃圾回收



## Java如何定义内存模型

 先了解几个概念，主存，高速缓存和处理器，为了解决现代存储设备和处理器运算速度不对等的矛盾，在每个处理器之间都加入了一个高速缓存来，数据先从主存中读取到高速缓存中，处理器处理完后再从高速缓存写回到主存。这样解决了处理器和存储的速度矛盾，但是也同时引入了一个新的问题，”内存一致性“。

 C++ 直接使用物理硬件和操作系统的内存模型，由于不同平台的差异，可能会导致在一台服务器运行正常，在另一台可能会出错。
 Java虚拟机规范中试图定义一种Java内存模型来屏蔽各种硬件和操作系统的内存访问差异。
 主要目标是定义程序中各个变量的访问规则，及虚拟机中如何将（共享）变量存储到内存以及如何去除这些细节。
 Java虚拟机的内存模型规定，所有的变量都存储在主存中(可以和物理硬件的内存做类比)，每条线程还有自己的工作内存（可以高速缓存做类比），工作内存中保存了线程需要的变量在主存中的副本拷贝，线程对变量的所有操作都必须在工作内存中进行，不能直接读写主内存中的变量，不同线程之间也无法直接访问对方工作内存中的变量。线程间变量值的传递需要通过主内存来完成。
 工作关系--看图，再看看两个线程之间的通信过程

##  主存和工作内存的交互协议

Java内存模型中定义了8中操作，虚拟机在实现时必须保证这些操作都是原子的，不可分割的。
lock:







## 指令重排

在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型： 

1. 编译器优化的重排序，编译器在不改变单线程程序语义的前提下，可以重新安排语句的还行顺序。
2. 指令级并行的重排序，现在处理器采用指令级并行技术，将多条指令重叠执行，如果不存在数据依赖，处理器可以改变语句对应机器指令的执行顺序。
3. 内存系统的重排序，处理器使用缓存和读/写缓冲区，是的加载和存储操作看上去可能是乱序。

 这些重排可能会导致多线程程序出现内存可见性问题。为了避免这种情况，JMM编译器重排序规则会禁止特定类型的编译器重排序，对于处理器重排序，JMM要求java编译器在生成指令是插入特定类型的**内存屏障**来精致特定处理器的指令重排。



### happen-before

Java虚拟机内存语义顺序规则，就是happens-before，定义了Java中两项内存操作的偏序语义，如果A happens-before B 那么A所能看到的内存才做，对于B来说都是可见的，那么就操作A的顺序在B的前面。Java内存模型中关happen-before的8条规定。

- 程序次序规则：单线程中先执行的每个动作`A`都`happens-before`于该线程后执行每一个动作`B`。【同一个线程的操作】 
- 监视器锁规则：对同一个监视器锁的解锁 `happens-before`于每一个后续对同一监视器锁的加锁。【可以多个线程】 
- `volatile`变量规则：同一个`volatile`域的写入操作`happens-before`于每一个后续对同一个域的读写操作。【可以多个线程】 
- 传递性：如果`A happens-before`于`B`，且`B happens-before`于`C`，则`A happens-before`于`C`。【可以多个线程】 



总结：在`Java`虚拟机层面所谓的指令重排序都是内存可见性的问题，所谓`A在B前面，其实说的是A所做的内存操作对于B都可见，而并不在乎这两个操作的CPU执行顺序`。 



## volatile（https://www.jianshu.com/p/16d2762a1d70）

看一段很经典的代码

```
package com.thunisoft.jvm.vol;

public class DoubleCheckSingle {

    //
    private static DoubleCheckSingle instance;

    public static DoubleCheckSingle getInstance(){
        //判断为空
        if(null==instance){
            //加锁
            synchronized (DoubleCheckSingle.class){
                //再次判断
                if(null==instance){
                    //new ----
                    instance = new DoubleCheckSingle();
                    
                    
                }
            }
        }
        return instance;
    }
}
```

这样的问题是什么呢？



   instance = new DoubleCheckSingle();可能是很多指令完成，我们做个简化理解，

1. 分配DoubleCheckSingle需要的内存空间。
2. 通过构造函数对内存空间初始化
3. 将内存空间地址复制给instance

CUP在执行指令可能是乱序的，先执行指令3，其他现场在判断是就可能的得到一个未初始化完成的对象。

那么加了volatile后为什么就可以了呢？

是不是会所加了volatile修饰符，CUP指令1,2,3就不会发生重排，顺序执行了呢？

可以这么理解，但是这里的不发生重排是Java内存语义上的顺序，不是CPU执行指令的时间顺序。



在`JVM`内存模型中，指令顺序其实值得就是内存是否可见的顺序，而并不是真正指令执行的时间顺序 。







## 垃圾回收

### 内存分布

主要学习下PermGen，和Metaspace

JDK8后

移除了PermGen,使用本地内存来存储元数据，称为为Metaspace。

他们之间的对比：

- 字符串常量池：从JDK7 8 字符串常量移到了Java heap。
- JDK7 虽然把字符串常量移到了java heap但是任然保留了PermGen ,jdk8 彻底移除。将方法区移动到



Metaspace的控制参数和意义：

- **-XX:MetaspaceSize**  元空间的大小，预估值，设置太大会延长GC的时间。

- **-XX:MaxMetaspaceSize** 是分配给类元数据空间的最大值，超过此值就会触发Full GC，此值默认没有限制，但应取决于系统内存的大小。JVM会动态地改变此值。

- 　**-XX:MinMetaspaceFreeRatio**，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集 　

- 　**-XX:MaxMetaspaceFreeRatio**，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集 



### 如何判断对象是否死亡

1.引用计数器

​    给每一个对象添加一个引用计数器，当用对象引用它，计数器就加一，当有有一个对他的引用失效，计数器就减一，只要是计数器为0的对象，就是没有被引用的对象。程序计数器，高效并且简单，但是现在主流的虚拟机都没用采用这种方式，主要原因是他无法解决对象之间相互引用的情况。

2.可达性分析

定义一系列成为“**GC Roots**”的对象作为起点，从这些对象向下搜索，所经过的路径叫做引用链，如果一个对象没有任何引用链，就表示这个对象可以被回收

那么那些对象可以被叫做**GC Roots**”呢？ 这个问题也困扰了我很久！

**GC Roots** 的主要节点在全局行的引用（例如常量或者静态类属性）与执行上下文中（例如栈帧中的本地变量表）。

如何实现GC Roots枚举：

如果每次都逐个的检查引用链，一般系统对象很多，可能方法去就几百兆，还有超过一个G的，那这个操作的时间会非常的长，那么如何能让这个操作更快呢？

可达性分析必须在一个能确保一致性的快照进行，就像系统停止在某个冻结点上，不能说在分析期间系统的对象引用关系还在发生变化，否则分析结果的准确性就得不到保证。所以GC在时必须停止所有JAVA线程（STOP THE WORD）.

在hotSopt虚拟机中，定义了一组叫做OopMap的数据来保存栈上本地变量到堆上对象的引用关系。我们知道，一个线程意味着一个栈，一个栈由多个栈帧组成，一个栈帧对应着一个方法，一个方法里面可能有多个**安全点**。 gc 发生时，程序首先运行到最近的一个安全点停下来，然后更新自己的 OopMap ，记下栈上哪些位置代表着引用。枚举根节点时，递归遍历每个栈帧的 OopMap ，通过栈中记录的被引用对象的内存地址，即可找到这些对象（ GC Roots ）。

OopMap实现GC  Roots快速枚举只是一个附带功能，它更主要的功能是实现JVM的准确式GC。

什么是叫准确式GC，什么叫保守式 GC ？什么叫半保守式 GC ？



### 内存分配策略

![](qiniu.baofeidyz.com/picgo-wjc1.png)

![](qiniu.baofeidyz.com/picgo-wjc/20190314160308.png)

Hostspot把年轻带分为三部分

Eden区和2个Survivor区（分别叫from（S1）和to（S2）） 。Eden和Survival的默认分配比例为8：1 



- 大多数新生代对象都在Eden区分配，当Eden区没有了足够的空间分配时，虚拟机就发起一起Minor GC.
- 大对象直接进去老年代，通过-XX: PretenureSizeThreshold 大于这个参数的对象将直接进入老年代。
- 长期存活的对象将进入老年代，如果对象在Eden出生并且经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄增加到一定程度（默认15岁），就会被晋升到老年代。对晋升到老年代的对象的阈值可以通过-XX:MaxTenuringThreshold设置。
- 动态对象年龄判断，虚拟机并不是要求所有对象必须到达年龄阀值才能晋升老年代，当Survivor的空间相同年龄的所有对象大小总和大于Survivor空间的一半时，年龄大于或者等于该年龄的对象直接进入老年代，无需要等到MaxTenuringThreshold中要求的年龄。 
- 







1. GC开始时，对象只会存在于Eden和S1中，GC开始后，Eden区所有的存货对象都会被移到S2.
2. S1中的对象根据年龄决定去向，年龄到达阀值（年龄阈值，可以通过-XX:MaxTenuringThreshold来设置) 的去老年代，没有到阀值的就被移到S2区。然后清空Eden和S1.
3. 这时候之前的S1和S2变换角色，第二步中S1被清空，变成了下次GC的S2区。





### 垃圾回收算法

#### 1.标记清除（垃圾回收的基础算法）

这种垃圾收集算法分为两步，第一步是标记，第二部是清除。

第一步，根据**GC Roots**那些根节点，标记出所有引用链上的所有对象，那么那些未被标记的对象就是没有引用链的对象，就是垃圾对象(我看书上说的是标记出所有需要回收的对象)。

第二部，清除掉所有未被标记的对象。

这种算法带来的问题，会导致出现大量的不连续的内存空间。那分配大对象时导致内存不够而发生GC。

#### 2.复制算法（新生代）

将内存分为相同的两块，每次只是用其中的一块，当这块内存快被用完时，将活着的对象移动到另一块内存，然后把这块使用的空间全部清除，这样每次回收的都是对内存的一半的回收。

优点：解决了效率问题并且不会产生内存碎片的情况。

缺点：浪费了一半的空间，还有就是如果对象存活率如果比较高的话，就有很多的复制操作，效率就会有所下降。

#### 3.标记整理（适用于老年代）

和标记清除算法前面阶段相似，标记处引用链上的对象，但是和标记清除算法不同的是，对于不可用对象不是直接清除，而是让可以用对象都向一端移动，最后清除边界以外的内存。

有点：同样是解决了内存碎片的问题。并且也不会浪费50%的空间。

缺点：还是标记和整理过程的效率问题

#### 4.分代收集

现在的商用虚拟机的垃圾收集器都采用分代收集，其实不是什么新的算法，只是根据虚拟机不同内存区域的特点来选择更好的收集算法。

对于新生代，很多对象都是**朝生夕死**，每次垃圾回收活动都有大量的对象死去，所以采用复制算法，只需要付出少量的复制生存下来的对象的成本就能完成垃圾回收。

对于老年代，对象存活率很高，采用复制算法的话成本就比较高了，所以必须采用标记清除或者标记整理算法。

### 垃圾收集器

年轻代

#### Serial

采用复制算法的新生代收集器，单线程收集器，使用复制算法。在进行垃圾收集时必须暂停其他所有的工作线程，直到Serial完成收集工作。著名的Stop The Word。

HostSpot虚拟机客户端模式下的默认新生代收集器。他的优势优势就是简单高效，没有线程之间的交互开销，在桌面程序中，收集几十M或者一两百M的新生代停顿可以控制在一百毫秒。

#### ParNew

Serial收集器的多线程版本，除了使用多线程其余特点几乎一样，配置和代码等等。

相对于Serial收集器没有什么特别大的创新，但很多服务端的虚拟机下首选的新生代收集器，并且能和CMS配合使用的只有ParNew和Serial。

单线程的情况下性能不比Serial,但是现在的服务器CPU数量越来越多，在多CPU情况下他开启的手机线程数与CPU的数量相同，但是也可以用**-XX:ParallerGCThreads**参数设置。

#### Parallel Scavenge

并行的多线程新生代收集器，采用复制算法。该收集器的目标是达到一个可控制的吞吐量。

**XX:+UseAdaptiveSizePolicy**使用了这个参数就不需要手工指定新生代的大小（-Xmn）、Eden和Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了。虚拟机根据当前系统的运行情况动态调整这些参数，以平衡一个最适合的停顿时间或者最大吞吐量，这种叫做GC自适应调节策略。

无法和CMS配合。



老年代

#### Serial Old 

是Serial 收集器的老年代版本，单线程，采用标记-整理算法。

主要是在客户端模式下的虚拟机使用。在服务端的主要作用：

- 在JDK1.5 以及之前版本（Parallel Old诞生以前）中与Parallel Scavenge收集器搭配使用。
- 作为CMS收集器的后备预案，在并发收集发生**Concurrent Mode Failure**时使用。

#### Parallel Old

Parallel scavenge收集器的老年代版本，使用多线程，采用**标记-整理**算法。注重吞吐量和CPU 资源敏感的场合，都可以有限考虑Parallel Scavenge+Parallel old收集器

#### CMS

全称，Concurrent Mark Sweep ,获得最短回收停顿时间为目标的收集器，适用于服务端上的Java应用，尤其是互联网和B/S系统，非常重视服务的响应速度。通过名称可以看出它是基于**标记-清除**算法实现。

工作流程分为4个步骤：

1. 初始化标记，只是标记**GC Roots**能直接关联到的对象，速度快但是也需要停止所有的工作线程

2. 并发标记：

3. 重新标记：修正并发标记期间，应为程序继续运行导致的标记发生的变动，标记那一部分变动的对象，时间介于初始化标记和并发标记之间，同时也需要停止所有工作线程。

4. 并发清除：

   优点：并发收集，用户线程和垃圾收集线程可以并发执行，低停顿。

   缺点：

   - 对CPU资源敏感，在并发标记阶段，虽然可以和用户线程并发，但是他会占用一部分的CPU资源。CMS默认的启动回收线程数为（cpu+3）/4，如果CPU 小于4个对程序影响较大，如果CPU负载比较大还要分一部分资源去做垃圾收集，可能会导致程序运行效率下降很大，但是会随着CPU数量的增加影响而减小。
   - 无法处理浮动垃圾，发生Concurrent Mode Failur时，由于CMD并发清除阶段用户线程还在运行，所以就有新的垃圾不断产生，这部分垃圾出现在并发标记之后，CMD无法再次处理它，只能等到下一次GC。
   - 标记-清除的老毛病，内存碎片较多，如果遇到需要分配大对象，那就麻烦了。

#### G1https://tech.meituan.com/2016/09/23/g1.html

一款面向服务端应用的垃圾收集器。该收集器的特点：

- 并行和并发：充分利用多CPU多核环境的硬件优势，缩短线程停顿的时间。

- 分代收集：分代收集的该年G1仍然保存，但是他可以不需要其他收集器来配合就可以地理完成这个堆的GC工作。

- 空间整理：从整体上看是基于**标记-整理**算法实现，从局部上基于**复制**算法。这样就不会产生内存空间碎片，有利于程序的长期运行。

- 可预测的停顿：降低停顿时间是CMS和G1的共同特点，但是G1能建立可以测的停顿时间模型，能够制定在一定长度的时间片段内，GC消耗时间不能超过多少毫秒，接近实时垃圾收集器。


启用参数：

-XX:+UseG1GC

重要概念：

##### Region

传统GC收集器是将连续的内存空间划分为，新生代，老年代和永久代（JDK8后移除了永久代，引入了元空间），G1收集器的各代存储地址不是连续的，每一代都使用了N个不连续大小的Region，每个Region占用一块连续的内存空间。H代表大对象区域，这种region专门用于存储巨大对象（humongous object，H-obj ），即大小等于region一半的对象。每个Region的大小是可以设置的参数-XX:G1HeapRegionSize 取值范围 2M-32M，必须是2的指数倍。

##### SATB(没有太仔细研究)

Snapshot-At-The-Beginning ,就是GC开始时候对活着对象的一个快照，作用是维持并发GC时的准确性，那么他是怎么做到的呢？

根据三色标记算法（只是一种概念），把对象的存在分为三种颜色，白色：未标记，标记阶段结束后就当作垃圾删除了。灰色：正在被标记，黑色：已经标记完成。

#####  RSet

要想知道知道对象的引用关系，做可达性分析要想保证准确性，就必须对整个堆的对象扫描，这显然非常影响GC效率，为了避免全堆扫描，G1每一个Region都有一个RSet，RSet记录了其他Region中的对象引用本Region中对象的关系，典型的Points-into结构，表示谁引用了我，每一个Rgion都记录了别的Rgion有指向自己的指针，那么这样的存储结果到底有什么用处呢？在做YGC的时候，只需要选定young generation region的RSet作为根集，这些RSet记录了old->young的跨代引用，避免了扫描整个old generation。 而mixed gc的时候，old generation中记录了old->old的RSet，young->old的引用由扫描全部young generation region得到，这样也不用扫描全部old generation region。所以RSet的引入大大减少了GC的工作量。 

##### 可以测的时间模型

G1 GC会有计划的避免在整个JAVA堆中进行全区域的垃圾收集，他会跟踪各个Region里面的垃圾堆积的价值大小(回收得到的空间大小以及所需时间的经验值)，在后台会委会一个优先级列表，每次根据哦诶之的允许收集时间，优先回收价值最大的Region。

-XX:MaxGCPauseMillis  设置GC 收集过程的停顿时间。

#### GC过程

GC步奏大致分为

1. 初始化标记: 只标记**GC Roots**能直接关联到的对象，并修改**TAMS（Nest Top Mark Start）**的值 ，让下一阶段用户程序并发运行时，能在正确可以的Region中创建对象，此阶段需要**停顿线程**，但耗时很短。 
2. 并发标记：从**GC Roots**开始对堆的对象做可达性分析，需要时间较长，但是不需要STW，可以和用户程序并发执行。
3. 最终标记：为了修正第二步中犹豫用户程序运行产生的引用变化，这部分记录呗虚拟机存到了RSet logszhong ,最后把数据合并到RSet中，这阶段需要STW，但是可以并发的执行。
4. 筛选回收：对各个Region中的会守家和成本进行排序，根据期望停顿时间制作计划，这个阶段是可以和用户程序并发，但是他只会回收一部分Rgion。



总结

| 收集器                | 串行、并行or并发 | 新生代/老年代 | 算法               | 目标         | 适用场景                                  |
| --------------------- | ---------------- | ------------- | ------------------ | ------------ | ----------------------------------------- |
| **Serial**            | 串行             | 新生代        | 复制算法           | 响应速度优先 | 单CPU环境下的Client模式                   |
| **Serial Old**        | 串行             | 老年代        | 标记-整理          | 响应速度优先 | 单CPU环境下的Client模式、CMS的后备预案    |
| **ParNew**            | 并行             | 新生代        | 复制算法           | 响应速度优先 | 多CPU环境时在Server模式下与CMS配合        |
| **Parallel Scavenge** | 并行             | 新生代        | 复制算法           | 吞吐量优先   | 在后台运算而不需要太多交互的任务          |
| **Parallel Old**      | 并行             | 老年代        | 标记-整理          | 吞吐量优先   | 在后台运算而不需要太多交互的任务          |
| **CMS**               | 并发             | 老年代        | 标记-清除          | 响应速度优先 | 集中在互联网站或B/S系统服务端上的Java应用 |
| **G1**                | 并发             | both          | 标记-整理+复制算法 | 响应速度优先 | 面向服务端应用，将来替换CMS               |

